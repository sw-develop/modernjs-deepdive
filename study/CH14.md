# CH14 전역변수의 문제점

- 전역 변수의 무분별한 사용은 위험함
- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 함

## ✔️ 변수의 생명 주기
- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖고 소멸하는 '생명 주기'를 가짐
- 변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지 임

## ▶️ 지역 변수의 생명 주기 
- 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸됨   
- 지역 변수의 생명 주기 == 함수의 생명 주기

<img width="438" alt="image" src="https://user-images.githubusercontent.com/69254943/149765398-531fef8b-0bb7-448b-9702-565c63b59caf.png">   

→ 함수 내부의 지역 변수는 함수 호출 직후 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됨   
→ 위의 예제에서 foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 전에 x 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화됨   


```javascript
var x = 'global';

function foo() {
    console.log(x); // ㄱ) undefined
    var x = 'local';
}

foo();
console.log(x); // global
```   
→ foo 함수 내부에서 선언된 지역 변수 x는 ㄱ 시점에 이미 선언되었고 undefined로 초기화되어 있음   
→ foo 함수 내부에서는 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조해 값을 출력함   
(= 지역 변수는 함수 전체에서 유효하고, 변수 할당문 실행 전까지 undefined 값을 가짐)   


### 지역 변수 호이스팅   
- 호이스팅은 스코프 단위로 동작함
- 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프 선두로 끌어 올려진 것처럼 동작함  
- 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말함


## ▶️ 전역 변수의 생명 주기
- 전역 코드는 명시적인 호출 없이 실행되므로, 코드가 로드되자마자 곧바로 해석되고 실행됨
- 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료됨
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨   
  (전역 변수의 생명 주기 == 전역 객체의 생명 주기)
  
<img width="402" alt="image" src="https://user-images.githubusercontent.com/69254943/149768565-e148b1f8-2837-4e46-aef5-67d6a8106b42.png">   
  
## ✔️ 전역 변수의 문제점
### ▶️ 암묵적 결합
- 전역 변수를 선언한 의도는 '코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것'
- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 '암묵적 결합(implicit coupling)'을 허용하는 것
- 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아짐

### ▶️ 긴 생명주기
- 전역 변수는 생명 주기가 기므로 메모리 리소스도 오랜 기간 소비함
- var 키워드는 변수의 중복 선언을 허용하므로 의도치 않은 재할당 이뤄짐


- 지역 변수는 전역 변수보다 생명 주기가 훨씬 짧음
  - 전역 변수보다 상태 변경에 의한 오류가 발생할 확률이 작고, 메모리 리소스도 짧은 기간만 소비함   


### ▶️ 스코프 체인 상에서 종점에 존재
- 전역 변수는 스코프 체인 상에서 종점에 존재함
    - 변수 검색 시 전역 변수가 가장 마지막에 검색된다는 것이므로, 전역 변수의 검색 속도가 가장 느림   


### ▶️ 네임스페이스 오염 
- 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유함 
    - 다른 파일 내에 동일한 이름으로 명명된 전역 변수 or 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과 초래 가능 



## ✔️ 전역 변수의 사용을 억제하는 방법
- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 함
- 변수의 스코프는 좁을수록 좋음


### ▶️ 즉시 실행 함수   
```javascript
(function () {
    var foo = 10; // 즉시 실행 함수의 지역 변수 
    // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```   
→ 함수 정의와 동시에 호출되는 즉시 실행 함수는 단 1번만 호출됨   
→ 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 실행 함수의 지역 변수가 됨(이 방법을 사용하면 전역 변수가 생성되지 않으므로 라이브러리 등에 자주 사용됨)   

### ▶️ 네임스페이스 객체 
```javascript
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Me';

console.log(MYAPP.name); // Me
```
→ 전역으로 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법      

### ▶️ 모듈 패턴
→ 클래스를 모방하여 관련 있는 변수 & 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 생성함   
→ 자바스크립트의 강력한 기능인 클로저를 기반으로 동작함   
→ But 자바스크립트는 접근 제한자(public, private, protected)를 제공하지 않으므로, 모듈 패턴은 전역 네임스페이스의 오염을 막고 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용함   
```javascript
var Counter = (function () {
    // private 변수
    var num = 0;
    
    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환함
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());

// private 변수는 외부 노출 X
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
```   
→ 위의 즉시 실행 함수는 객체를 반환함(return {};)   
→ 반환되는 객체의 프로퍼티는 public 이고, 반환하는 객체에 추가되지 않은 것은 private임    

### ▶️ ES6 모듈
→ ES6 모듈 사용시 전역 변수 사용 X   
→ ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공함   

 

