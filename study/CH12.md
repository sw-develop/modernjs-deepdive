# CH12 함수

## ✔️ 함수를 사용하는 이유
- 코드의 재사용 : 동일한 작업을 반복적으로 수행해야 한다면, 미리 정의된 함수를 재사용하는 것이 효율적임
- 유지보수의 편의성 & 코드의 신뢰성 : 코드의 중복을 억제하고 재사용성을 높이는 함수를 통해 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높임

## ✔️ 함수 리터럴 
→ 자바스크립트의 함수는 객체 타입의 값임 (함수도 리터럴로 생성할 수 있음)   
```javascript
// 변수에 함수 리터럴을 할당 
var f = function add(x,y){
    return x + y;
};
```
→ 일반 객체는 호출할 수 없지만 함수는 호출할 수 있음 (이때, 함수 이름으로 호출하는 것이 X, 함수 객체를 가리키는 식별자로 호출함)      
→ **함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징!**

▶️ 함수 리터럴로 생성한 함수 객체를 변수에 할당하여 함수를 정의하는 방식을 '함수 표현식' 이라고 함!

## ✔️ 함수 정의
→ 함수 정의 : 함수를 호출하기 이전에 인수를 전달받을 매개변수, 실행할 문들, 반환 값을 지정하는 것   
→ 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨   

## ✔️ 함수 정의하는 4가지 방법
### 1) 함수 선언문
```javascript
function add(x, y) {
    return x + y;
}
```
→ 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없음   
→ 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없음   

⚠️ **자바스크립트 엔진은 코드의 문맥에 따라 {}를 코드 블럭 or 객체 리터럴로 해석할지 달라짐**
```javascript
// 1. 함수 선언문 해석 - 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석됨
function foo() { console.log('foo'); }
foo(); 

// 2. 함수 리터럴 표현식 해석 - 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석됨
(function bar() { console.log('bar'); });
bar();  // ReferenceError : bar is not defined
```
→ **함수 리터럴에서 '함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임'** (따라서 위의 bar(); 는 참조 에러가 발생함)   
→ **함수 선언문으로 정의된 함수 이름을 호출할 수 있는 이유** : 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함   
(공통적으로 함수 이름은 함수 몸체 내부에서만 유효한 식별자로 함수 이름과는 별도의 생성된 함수 객체를 가리키는 식별자가 필요함)   


### 2) 함수 표현식
→ 함수 표현식 : 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식   
```javascript
var add = function (x,y) {
    return x + y;
};
```
→ 함수 리터럴의 함수 이름은 생략할 수 있고, 이러한 함수를 익명 함수라고 함 (함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적)   
→ 자바스크립트의 함수는 객체 타입의 값이므로 값처럼 변수에 할당할 수 있고, 프로퍼티 값이 될 수도 있고, 배열의 요소가 될 수도 있음   
→ 이러한 값의 성질을 갖는 객체를 '일급 객체'라고 함 (= 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미임)   

### 💡 함수 생성 시점과 함수 호이스팅 (함수 선언문 & 함수 표현식)
```javascript
// 함수 참조
console.dir(add);   // f add(x,y)
console.dir(sub);   // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError : sub is not a function

// 함수 선언문
function add(x, y){
    return x + y;
}

// 함수 표현식
var sub = function (x, y){
    return x - y;
};
```
→ 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문에, 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있고, 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음   

- 함수 선언문   
  → 런타임 이전에 함수 객체가 먼저 생성되고, 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당함   
  → 이러한 특징을 ' 함수 호이스팅 ' 이라고 함  
  

- 함수 표현식   
  → 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문   
  → 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨   
  → 함수 표현식으로 함수를 정의하면, 함수 호이스팅 발생 X --> 변수 호이스팅 발생함

▶️ 함수 호이스팅은 함수 호출 전 반드시 함수를 선언해야 한다는 규칙을 무시하므로, 일반적으로 함수 선언문 대신 **함수 표현식 사용을 권장함**   

### 3) Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');
```
→ 자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록, 함수 문제를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환함   
→ But, Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지 X

### 4) 화살표 함수(ES6)
```javascript
var add = (x, y) => x + y;
```
→ ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간략한 함수 선언 방식임   
→ 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화 되어 있음   


